<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>my first blog</title>
    <link href="/2023/03/11/my-first-blog/"/>
    <url>/2023/03/11/my-first-blog/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2023/03/11/hello-world/"/>
    <url>/2023/03/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>001 常量、变量</title>
    <link href="/2020/02/10/001%20%E5%89%8D%E8%A8%80%E3%80%81%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F/"/>
    <url>/2020/02/10/001%20%E5%89%8D%E8%A8%80%E3%80%81%E5%85%A5%E9%97%A8%E7%A8%8B%E5%BA%8F%E3%80%81%E5%B8%B8%E9%87%8F%E3%80%81%E5%8F%98%E9%87%8F/</url>
    
    <content type="html"><![CDATA[<p><a name="GAQAR"></a></p><h1 id="常见Dos命令"><a href="#常见Dos命令" class="headerlink" title="常见Dos命令"></a>常见Dos命令</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650617063400-c7f585ce-e275-4131-b142-7684aee9b1e5.png#averageHue=%23f8f7f7&clientId=u27cb9286-f397-4&from=paste&height=234&id=u91d6ab1b&name=image.png&originHeight=293&originWidth=695&originalType=binary&ratio=1&rotation=0&showTitle=false&size=32324&status=done&style=none&taskId=uf17940da-5673-412e-95f4-194afb39cfc&title=&width=556" alt="image.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java">#<span class="hljs-number">1</span> 盘符切换 盘前缀加:(注意英文文)<br>#查看当前目录下的所有文件  dir+回车<br>#切换目录   cd(命令) change directory    <br>#  cd/d  可以进行跨盘符切换  切换格式：cd/d（参数斜杠） d(盘)：\(文件斜杠)   注意这个:不要重复使用<br>#  cd.. 返回上一级  <br>#  cd+目录名，进入该目录    这里没有：号<br><br>#<span class="hljs-number">2</span> 清理屏幕<br>#  cls  (clear screen)<br><br>#<span class="hljs-number">3</span> 退出终端 <br># exit<br><br>#<span class="hljs-number">4</span> 查看电脑ip<br># ipconfig  加all是全开？<br><br>#<span class="hljs-number">5</span> calc 计数器   mspaint  画图   notepad  记事本<br><br>#<span class="hljs-number">6</span> ping 命令<br>ping www.baidu.com  作用：测试网络是否正常    小知识，Cmd右键粘贴<br><br>#<span class="hljs-number">7</span> md test 创建一个名为 test的文件夹<br>#  cd&gt;a.txt 创建一个名为a的txt  同理可以创建其他格式文件<br><br>#<span class="hljs-number">8</span> 删除目录<br># 先删除文件  del a.txt<br># 删除目录： rd test<br><br></code></pre></td></tr></table></figure><p><a name="Es5Ah"></a></p><h1 id="JVM-JDK-JRE"><a href="#JVM-JDK-JRE" class="headerlink" title="JVM,JDK,JRE"></a>JVM,JDK,JRE</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650617088710-e3c1b203-a1b7-4bf8-acdb-d982b9c98b2a.png#averageHue=%23f8f7f5&clientId=u27cb9286-f397-4&from=paste&height=542&id=uac529762&name=image.png&originHeight=677&originWidth=757&originalType=binary&ratio=1&rotation=0&showTitle=false&size=239604&status=done&style=none&taskId=u0bbbfdbe-09ce-42bd-a11f-899c1bf0436&title=&width=605.6" alt="image.png"><br><a name="O2f21"></a></p><h1 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h1><p>环境变量（environment variables）一般是指在<a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统</a>中用来指定操作系统运行环境的一些参数，如：<a href="https://baike.baidu.com/item/%E4%B8%B4%E6%97%B6%E6%96%87%E4%BB%B6%E5%A4%B9/1061467">临时文件夹</a>位置和<a href="https://baike.baidu.com/item/%E7%B3%BB%E7%BB%9F%E6%96%87%E4%BB%B6%E5%A4%B9/5328647">系统文件夹</a>位置等。<br />       环境<a href="https://baike.baidu.com/item/%E5%8F%98%E9%87%8F">变量</a>是在操作系统中一个具有特定名字的对象，它包含了一个或者多个应用<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F">程序</a>所将使用到的信息。例如<a href="https://baike.baidu.com/item/Windows/165458">Windows</a>和<a href="https://baike.baidu.com/item/DOS/32025">DOS</a>操作系统中的path环境变量，当要求系统运行一个<a href="https://baike.baidu.com/item/%E7%A8%8B%E5%BA%8F/71525">程序</a>而没有告诉它程序所在的完整路径时，系统除了在<a href="https://baike.baidu.com/item/%E5%BD%93%E5%89%8D%E7%9B%AE%E5%BD%95/7205107">当前目录</a>下面寻找此程序外，还应到path中指定的路径去找。用户通过设置环境<a href="https://baike.baidu.com/item/%E5%8F%98%E9%87%8F">变量</a>，来更好的运行进程。</p><ol><li>环境变量配置在path路径中的是有优先级的；</li></ol><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1648812140801-44934c38-b778-4d93-920c-87d7f23aa073.png#averageHue=%23f5f3f1&clientId=u2d2cec3f-7a03-4&from=paste&height=171&id=u29faa5ad&name=image.png&originHeight=342&originWidth=636&originalType=binary&ratio=1&rotation=0&showTitle=false&size=29690&status=done&style=none&taskId=u877ebad4-5c46-4df8-9119-47b0240c6d4&title=&width=318" alt="image.png"></p><p><a name="HTRO3"></a></p><h1 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h1><p><strong>标识符</strong>：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。 </p><ul><li>HelloWorld案例中，出现的标识符有类名字 HelloWorld 。**类型 **</li></ul><p>**命名规则： 硬性要求 **</p><ul><li>标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。 </li><li>标识符不能以数字开头。 </li><li>标识符不能是关键字。</li></ul><p>**命名规范： 软性建议 **</p><ul><li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。 </li><li>方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。 </li><li>变量名规范：全部小写。</li></ul><p><a name="UYoJo"></a></p><h1 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h1><p>**常量：是指在Java程序中固定不变的数据。 **<br><a name="Z4jFN"></a></p><h1 id=""><a href="#" class="headerlink" title=""></a></h1><p><strong>变量和数据类型</strong><br />**变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量。 **<br />变量定义的格式包括三个要素： 数据类型 、 变量名 、 数据值 <br />**数据类型分类 **<br />Java的数据类型分为两大类： </p><ul><li><strong>基本数据类型</strong>：包括 整数 、 浮点数 、 字符 、 布尔 。 </li><li><strong>引用数据类型</strong>：包括 类 、 数组 、 接口 。</li></ul><p>**基本数据类型 **<br />四类八种基本数据类型： <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650617280372-32a69872-9abb-404e-a38c-4d73f6e877e2.png#averageHue=%23f4f3f2&clientId=u27cb9286-f397-4&from=paste&height=247&id=ue8c6ff7a&name=image.png&originHeight=309&originWidth=675&originalType=binary&ratio=1&rotation=0&showTitle=false&size=57104&status=done&style=none&taskId=u58af763a-3358-443f-a003-6282734f68c&title=&width=540" alt="image.png"><br />Java中的默认类型：整数类型是 int 、浮点类型是 double 。</p><p>**注意事项 **</p><ul><li>变量名称：在同一个大括号范围内，变量的名字不可以相同。 </li><li>变量赋值：定义的变量，不赋值不能使用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaSe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>常量</tag>
      
      <tag>变量</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>002 数据类型转换、运算符、方法入门</title>
    <link href="/2020/02/10/002%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E6%96%B9%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <url>/2020/02/10/002%20%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E6%96%B9%E6%B3%95%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<p><a name="Fx95e"></a></p><h1 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a><strong>自动转换</strong></h1><p><strong>自动转换</strong>：将 取值范围小的类型 自动提升为 取值范围大的类型 。<br />**转换原理图解 **<br />byte 类型内存占有1个字节，在和 int 类型运算时会提升为 int 类型 ，自动补充3个字节，因此计算后的结果还是 int 类 <br />型。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650617591114-255502cf-4d67-454e-8d6c-e9b165813973.png#clientId=u4becbbea-17fa-4&from=paste&height=292&id=ue41785e2&name=image.png&originHeight=365&originWidth=571&originalType=binary&ratio=1&rotation=0&showTitle=false&size=110529&status=done&style=none&taskId=u706be54f-c1e5-4f72-a340-12f40a1bea1&title=&width=456.8" alt="image.png"><br><a name="um8dC"></a></p><h1 id="转换规则"><a href="#转换规则" class="headerlink" title="转换规则"></a>转换规则</h1><p>范围小的类型向范围大的类型提升， byte 、short、char 运算时直接提升为 int <br /><code>byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double</code></p><p><a name="nvX0i"></a></p><h1 id="强制转换"><a href="#强制转换" class="headerlink" title="强制转换"></a>强制转换</h1><p>强制类型转换 ：将 取值范围大的类型 强制转换成 取值范围小的类型 <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650618160082-a1ccc9d9-75f9-4d99-b1a1-63fcb5173bcb.png#clientId=u4becbbea-17fa-4&from=paste&height=394&id=udd96ba39&name=image.png&originHeight=493&originWidth=631&originalType=binary&ratio=1&rotation=0&showTitle=false&size=127625&status=done&style=none&taskId=ub368caf7-e60a-4fe9-905d-d75e24b7efc&title=&width=504.8" alt="image.png"><br><a name="Z4jFN"></a></p><h1 id="Java数据类型分为两大类"><a href="#Java数据类型分为两大类" class="headerlink" title="Java数据类型分为两大类"></a>Java数据类型分为两大类</h1><ol><li>基本数据类型 : 整型、浮点型、字符型、布尔;</li><li>引用数据类型 : 类 、数组、 接口。</li></ol><p><a name="z234e"></a></p><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1648952655299-86fdb702-2a21-4f19-89f9-265811139484.png#clientId=u3f78424a-bffa-4&from=paste&height=346&id=u8c8f1e54&name=image.png&originHeight=622&originWidth=1042&originalType=binary&ratio=1&rotation=0&showTitle=false&size=90543&status=done&style=none&taskId=u6b2f9626-9352-48b9-896f-5dd84786fd6&title=&width=579" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1648953778850-5316d0b6-501f-4364-bf14-70a62ea3fd69.png#clientId=u3f78424a-bffa-4&from=paste&height=70&id=u9397b00f&name=image.png&originHeight=104&originWidth=483&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10857&status=done&style=none&taskId=u1a060519-66ae-44a4-8db0-4b141747202&title=&width=323.5" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1648954116024-ea6b7241-5933-46de-b769-b6d52eeed1de.png#clientId=u3f78424a-bffa-4&from=paste&height=85&id=ue8f108aa&name=image.png&originHeight=119&originWidth=435&originalType=binary&ratio=1&rotation=0&showTitle=false&size=3942&status=done&style=none&taskId=ud74d9f66-14f6-4990-88b6-a0416b15232&title=&width=310.5" alt="image.png"><br><a name="auua2"></a></p><h1 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h1><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1648974132161-3b5eeff0-fad5-4630-becd-c0a786ee4491.png#clientId=u681371cf-117c-4&from=paste&height=306&id=u868e07ff&name=image.png&originHeight=612&originWidth=885&originalType=binary&ratio=1&rotation=0&showTitle=false&size=67434&status=done&style=none&taskId=u51a793aa-629f-465a-9bb6-00a5536e7cb&title=&width=442.5" alt="image.png"><br />‘a’的ASCII码为97</p><p><a name="g6DIe"></a></p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><p>++a和a++,前者是先自加再参与运算，后者相反<br />a &#x3D; a++与a &#x3D; ++a均为先计算后赋值，不同的是: <br />a &#x3D; a++中变量先压栈，后计算，最后栈顶元素弹出赋值于a; <br />a &#x3D; ++a中变量先计算，后压栈，最后栈顶元素弹出赋值于a.</p><p><a name="rh527"></a></p><h2 id="x3D-具有强制转换的特点"><a href="#x3D-具有强制转换的特点" class="headerlink" title="+&#x3D;具有强制转换的特点"></a>+&#x3D;具有强制转换的特点</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123; <br>    <span class="hljs-type">short</span> <span class="hljs-variable">s</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; <br>    s+=<span class="hljs-number">1</span>; <br>    System.out.println(s); <br>&#125;<br></code></pre></td></tr></table></figure><p>s +&#x3D; 1 逻辑上看作是 s &#x3D; s + 1 计算结果被提升为int类型，再向short类型赋值时发生错误，因为不能将取值范围 <br />大的类型赋值到取值范围小的类型。但是， s&#x3D;s+1进行两次运算 ， +&#x3D; 是一个运算符，只运算一次，并带有强制转换的特点， <br />也就是说 s +&#x3D; 1 就是 s &#x3D; (short)(s + 1) ，因此程序没有问题编译通过，运行结果是2.</p><p><a name="FBB8F"></a></p><h2 id="常量和变量的运算"><a href="#常量和变量的运算" class="headerlink" title="常量和变量的运算"></a>常量和变量的运算</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span>&#123; <br>    <span class="hljs-type">byte</span> b1=<span class="hljs-number">1</span>; <br>    <span class="hljs-type">byte</span> b2=<span class="hljs-number">2</span>; <br>    <span class="hljs-type">byte</span> b3=<span class="hljs-number">1</span> + <span class="hljs-number">2</span>; <br>    <span class="hljs-type">byte</span> b4=b1 + b2;<br>    System.out.println(b3); <br>    System.out.println(b4); <br>&#125;<br></code></pre></td></tr></table></figure><p>分析： b3 &#x3D; 1 + 2 ， 1 和 2 是常量，为固定不变的数据，在编译的时候（编译器javac），已经确定了 1+2 的结果并没 有超过byte类型的取值范围，可以赋值给变量 b3 ，因此 b3&#x3D;1 + 2 是正确的。 <br />反之， b4 &#x3D; b2 + b3 ， b2 和 b3 是变量，变量的值是可能变化的，在编译的时候，编译器javac不确定b2+b3的结果是什 <br />么，因此会将结果以int类型进行处理，所以int类型不能赋值给byte类型，因此编译失败。 </p><p><a name="nvMcK"></a></p><h2 id="不引入第三个变量交换变量值"><a href="#不引入第三个变量交换变量值" class="headerlink" title="不引入第三个变量交换变量值"></a>不引入第三个变量交换变量值</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">a = a + b;<br>b = a - b；<br>a = a - b；<br></code></pre></td></tr></table></figure><p>&amp;&amp;短路与，&amp;按位与<br />&amp;位运算</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(<span class="hljs-number">10</span>&amp;<span class="hljs-number">2</span>);<span class="hljs-comment">//2</span><br>        <span class="hljs-number">0000</span> <span class="hljs-number">1010</span><br>        <span class="hljs-number">0000</span> <span class="hljs-number">0010</span><br>        <span class="hljs-number">0000</span> <span class="hljs-number">0010</span><br></code></pre></td></tr></table></figure><p>~ 取反运算<br />^ 异或</p><p>取值范围大的类型赋值给取值范围小的类型可能会有精度丢失,+&#x3D;还带有强制转换的特点<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1649248101741-a3118c15-6a7f-4bea-9b0c-dbfee715d021.png#clientId=u95f3aaa2-4c92-4&from=paste&height=182&id=uded05489&name=image.png&originHeight=282&originWidth=1055&originalType=binary&ratio=1&rotation=0&showTitle=false&size=212719&status=done&style=none&taskId=u90006ee0-f4c7-46d7-a189-76899e99f99&title=&width=681.4000244140625" alt="image.png"></p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1649248381714-60b9bef8-e163-4726-b513-2c7facce7250.png#clientId=u95f3aaa2-4c92-4&from=paste&height=191&id=u6ccd9be1&name=image.png&originHeight=218&originWidth=755&originalType=binary&ratio=1&rotation=0&showTitle=false&size=26589&status=done&style=none&taskId=ud022cf25-34c8-43a8-a4e8-63b14d40752&title=&width=661.5" alt="image.png"></p><p><a name="BMlLf"></a></p><h1 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h1><p>我们在学习运算符的时候，都为每个运算符单独的创建一个新的类和main方法，我们会发现这样编写代码非常的繁琐，而且 <br />重复的代码过多。能否避免这些重复的代码呢，就需要使用方法来实现。 </p><ul><li><strong>方法：</strong>就是将一个<strong>功能</strong>抽取出来，把代码单独定义在一个大括号内，形成一个单独的功能。</li></ul><p>当我们需要这个功能的时候，就可以去调用。这样即实现了代码的复用性，也解决了代码冗余的现象。 </p><p><a name="JZokx"></a></p><h1 id="JShell"><a href="#JShell" class="headerlink" title="JShell"></a>JShell</h1><p>**JShell脚本工具是JDK9的新特性 **<br />什么时候会用到 JShell 工具呢，当我们编写的代码非常少的时候，而又不愿意编写类，main方法，也不愿意去编译和运 <br />行，这个时候可以使用JShell工具。</p>]]></content>
    
    
    <categories>
      
      <category>JavaSe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据类型转换</tag>
      
      <tag>运算符</tag>
      
      <tag>方法入门</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>003 流程控制语句</title>
    <link href="/2020/02/10/003%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/"/>
    <url>/2020/02/10/003%20%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<p>switch(表达式) <br />{ <br />case 常量值1: 语句体1; break; <br />case 常量值2: 语句体2; break; <br />… default: 语句体n+1; break;<br /> }  <br />没有break会有穿透效果</p><p>第一个死循环后不能写,第二个可以是因为J是一个变量,编译器不能断定J会造成死循环<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1649418648198-473513f6-8104-40db-8f03-994e1095b669.png#clientId=uac2280ef-fb82-4&from=paste&height=382&id=u85654bcd&name=image.png&originHeight=423&originWidth=565&originalType=binary&ratio=1&rotation=0&showTitle=false&size=106450&status=done&style=none&taskId=u072c77bf-92cb-47f2-9f1a-47c0a7c07d4&title=&width=510.5" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>JavaSe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>流程控制语句</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>004 IDEA、方法</title>
    <link href="/2020/02/10/004%20IDEA%E3%80%81%E6%96%B9%E6%B3%95/"/>
    <url>/2020/02/10/004%20IDEA%E3%80%81%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><a name="MiVKS"></a></p><h1 id="方法重载"><a href="#方法重载" class="headerlink" title="方法重载"></a>方法重载</h1><ul><li><strong>方法重载</strong>：指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符返回值类型无关。 </li><li>参数列表：个数不同，数据类型不同，顺序不同。 </li><li>重载方法调用：JVM通过方法的参数列表，调用不同的方法。</li></ul>]]></content>
    
    
    <categories>
      
      <category>JavaSe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>006 类与对象、封装、构造方法</title>
    <link href="/2020/02/10/006%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/"/>
    <url>/2020/02/10/006%20%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E3%80%81%E5%B0%81%E8%A3%85%E3%80%81%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p>**什么是类 **</p><ul><li><strong>类</strong>：是一组相关<strong>属性</strong>和<strong>行为</strong>的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。</li><li><strong>属性</strong>：就是该事物的状态信息。 </li><li><strong>行为</strong>：就是该事物能够做什么。 </li><li><br /></li></ul><p><strong>什么是对象 <strong><br /><strong>对象</strong>：是一类事物的具体体现。对象是类的一个</strong>实例</strong>（对象并不是找个女朋友），必然具备该类事物的属性 和行为。 </p><p>**类与对象的关系 **</p><ul><li>类是对一类事物的描述，是<strong>抽象的</strong>。 </li><li>对象是一类事物的实例，是<strong>具体的</strong>。 </li><li><strong>类是对象的模板，对象是类的实体</strong>。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650619401387-07fe92fd-bc3a-4ba5-b3c9-70b7c3fe11ca.png#clientId=ufcf332fd-e885-4&from=paste&height=354&id=u8f0ed3c4&name=image.png&originHeight=443&originWidth=705&originalType=binary&ratio=1&rotation=0&showTitle=false&size=211938&status=done&style=none&taskId=u5c3638f0-ed72-4180-bfd7-69ffba30118&title=&width=564" alt="image.png"><br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650619445914-efc784d4-f7be-4b19-be23-7a67027b3bba.png#clientId=ufcf332fd-e885-4&from=paste&height=278&id=u0997a6f2&name=image.png&originHeight=347&originWidth=692&originalType=binary&ratio=1&rotation=0&showTitle=false&size=207499&status=done&style=none&taskId=uc19f69ad-d75c-4f4e-9aeb-93fc25ce884&title=&width=553.6" alt="image.png"></p><p><a name="j7cwk"></a></p><h1 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h1><p><strong>概述</strong><br />面向对象编程语言是对客观世界的模拟，客观世界里成员变量都是隐藏在对象内部的，外界无法直接操作和修改。 <br />封装可以被认为是一个保护屏障，防止该类的代码和数据被其他类随意访问。要访问该类的数据，必须通过指定的方式。适当的封装可以让代码更容易理解与维护，也加强了代码的安全性。 <br /><strong>原则</strong><br />将<strong>属性隐藏</strong>起来，若需要访问某个属性，<strong>提供公共方法</strong>对其访问。 </p><p><a name="YIFOI"></a></p><h1 id="this"><a href="#this" class="headerlink" title="this"></a>this</h1><p>this代表所在类的当前对象的引用（地址值），即对象自己的引用。 <br />记住 ：方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。 </p>]]></content>
    
    
    <categories>
      
      <category>JavaSe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>类与对象 - 封装 - 构造方法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>007 Scanner、Random、ArrayList类</title>
    <link href="/2020/02/10/007%20Scanner%E7%B1%BB%E3%80%81Random%E7%B1%BB%E3%80%81ArrayList%E7%B1%BB/"/>
    <url>/2020/02/10/007%20Scanner%E7%B1%BB%E3%80%81Random%E7%B1%BB%E3%80%81ArrayList%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p><a name="UtRPf"></a></p><h1 id="Scanner"><a href="#Scanner" class="headerlink" title="Scanner"></a>Scanner</h1><p>一个可以解析基本类型和字符串的简单文本扫描器</p><p><a name="o0AVj"></a></p><h1 id="Random"><a href="#Random" class="headerlink" title="Random"></a>Random</h1><p>public int nextInt(int n) ：返回一个伪随机数，范围在 0 （包括）和 指定值 n （不包括）之间的 int 值。 </p><p><a name="wbAJc"></a></p><h1 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h1><p>java.util.ArrayList 是大小<strong>可变的数组</strong>的实现，存储在内的数据称为元素。此类提供一些方法来操作内部存储的元素。 ArrayList 中可不断添加元素，其大小也自动增长。<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650619830027-da85ab6a-88b5-4ec6-8a78-8feb904a238a.png#clientId=u074eb56e-009e-4&from=paste&height=258&id=u2b9d5b55&name=image.png&originHeight=322&originWidth=677&originalType=binary&ratio=1&rotation=0&showTitle=false&size=20648&status=done&style=none&taskId=u56ddade9-7ba4-4a4d-a6ee-d3e0e3d13ca&title=&width=541.6" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>JavaSe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Scanner</tag>
      
      <tag>Random</tag>
      
      <tag>ArrayList类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>008 String类、static、Array类、Math类</title>
    <link href="/2020/02/10/008%20String%E7%B1%BB%E3%80%81static%E3%80%81Arrays%E7%B1%BB%E3%80%81Math%E7%B1%BB/"/>
    <url>/2020/02/10/008%20String%E7%B1%BB%E3%80%81static%E3%80%81Arrays%E7%B1%BB%E3%80%81Math%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p><a name="sGo4g"></a></p><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul><li><p>public String() ：初始化新创建的 String对象，以使其表示空字符序列。 </p></li><li><p>public String(char[] value) ：通过当前参数中的字符数组来构造新的String。 </p></li><li><p>public String(byte[] bytes) ：通过使用平台的默认字符集解码当前参数中的字节数组来构造新的 String。</p></li><li><p>public boolean equals (Object anObject) ：将此字符串与指定对象进行比较。 </p></li><li><p>public boolean equalsIgnoreCase (String anotherString) ：将此字符串与指定对象进行比较，忽略大小 写。</p></li><li><p>public int length () ：返回此字符串的长度。 </p></li><li><p>public String concat (String str) ：将指定的字符串连接到该字符串的末尾。 </p></li><li><p>public char charAt (int index) ：返回指定索引处的 char值。 </p></li><li><p>public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。 </p></li><li><p>public String substring (int beginIndex) ：返回一个子字符串，从beginIndex开始截取字符串到字符串结尾。 </p></li><li><p>public String substring (int beginIndex, int endIndex) ：返回一个子字符串，从beginIndex到 </p></li><li><p>endIndex截取字符串。含beginIndex，不含endIndex。 </p></li><li><p>public char[] toCharArray () ：将此字符串转换为新的字符数组。 </p></li><li><p>public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。 </p></li><li><p>public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。 </p></li><li><p>public String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。</p></li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650455043221-f3701f2e-3c51-4844-8e43-8acdde942336.png#clientId=ude6fb2a6-a833-4&from=paste&height=348&id=u65f6a7af&name=image.png&originHeight=435&originWidth=1103&originalType=binary&ratio=1&rotation=0&showTitle=false&size=31548&status=done&style=none&taskId=uf15e1226-6507-4c4d-a076-11316bbaee6&title=&width=882.4" alt="image.png"><br><a name="iy0L6"></a></p><h1 id="Static"><a href="#Static" class="headerlink" title="Static"></a>Static</h1><p>关于 static 关键字的使用，它可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属 于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。</p><p><a name="eqij6"></a></p><h2 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h2><ul><li>当 static 修饰成员变量时，该变量称为<strong>类变量</strong>。该类的每个对象都<strong>共享</strong>同一个类变量的值。任何对象都可以更改该类变量的值，但也可以在不创建该类的对象的情况下对类变量进行操作。</li></ul><p><strong>类变量</strong>：使用 static关键字修饰的成员变量。 </p><p><a name="rIFhn"></a></p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul><li>当 static 修饰成员方法时，该方法称为**类方法 **。静态方法在声明中有 static ，建议使用类名来调用，而不需要 创建类的对象。调用方式非常简单。</li></ul><p><strong>类方法</strong>：使用 static关键字修饰的成员方法，习惯称为<strong>静态方法</strong>。</p><p>**静态方法调用的注意事项： **</p><ul><li>静态方法可以直接访问类变量和静态方法。 </li><li>静态方法<strong>不能直接访问</strong>普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。 </li><li>静态方法中，不能使用<strong>this</strong>关键字。</li></ul><p>小贴士：静态方法只能访问静态成员。 </p><p>被static修饰的成员可以并且建议通过<strong>类名直接访问</strong>。虽然也可以通过对象名访问静态成员，原因即多个对象均属 于一个类，共享使用同一个静态成员，但是不建议，会出现警告信息。 </p><p><a name="gPzwX"></a></p><h2 id="静态原理图解"><a href="#静态原理图解" class="headerlink" title="静态原理图解"></a>静态原理图解</h2><p>static 修饰的内容： </p><ul><li>是随着类的加载而加载的，且只加载一次。 </li><li>存储于一块固定的内存区域（静态区），所以，可以直接被类名调用。 </li><li>它优先于对象存在，所以，可以被所有对象共享。</li></ul><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650620403195-6ecc84bd-8b4d-4280-bc5c-be325dc323a8.png#clientId=u58bbdc70-3f60-4&from=paste&height=244&id=u9ad06d5c&name=image.png&originHeight=305&originWidth=700&originalType=binary&ratio=1&rotation=0&showTitle=false&size=232174&status=done&style=none&taskId=u669c2fdc-94c0-4075-ad66-4c250b5cfee&title=&width=560" alt="image.png"><br><a name="Rchg6"></a></p><h2 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h2><p>定义在成员位置，使用static修饰的代码块{ }。 </p><ul><li>位置：类中方法外。 </li><li>执行：随着类的加载而执行且执行一次，优先于main方法和构造方法的执行。</li></ul><p>小贴士： <br />static 关键字，可以修饰变量、方法和代码块。在使用的过程中，其主要目的还是想在不创建对象的情况下，去调用方法。<br><a name="EuMj1"></a></p><h4 id=""><a href="#" class="headerlink" title=""></a><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650457486879-fab0c412-8b4f-481e-bab5-6a2db6dd4a86.png#clientId=ude6fb2a6-a833-4&from=paste&height=562&id=u0adb662c&name=image.png&originHeight=703&originWidth=744&originalType=binary&ratio=1&rotation=0&showTitle=false&size=217582&status=done&style=none&taskId=udd4ddefa-4604-44aa-8a08-e8117c87b00&title=&width=595.2" alt="image.png"></h4><p>show()方法中的,name实际上是this.name(在本类中不产生冲突是可以省略的),调用show方法的对象在使用改成员方法</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650539541515-d5e8de26-d9a5-44c4-bc2a-dbc66dab98f9.png#clientId=u9786de69-939b-4&from=paste&height=482&id=u93d4e211&name=image.png&originHeight=603&originWidth=461&originalType=binary&ratio=1&rotation=0&showTitle=false&size=103923&status=done&style=none&taskId=u4aec7a19-5559-4af2-bfe4-1169a92c2db&title=&width=368.8" alt="image.png"><br />反编译之后<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650539566173-017274cb-09fd-4d5d-baa3-8ddab39feb17.png#clientId=u9786de69-939b-4&from=paste&height=385&id=u701dcd94&name=image.png&originHeight=481&originWidth=394&originalType=binary&ratio=1&rotation=0&showTitle=false&size=104364&status=done&style=none&taskId=ua51fbde1-22eb-4704-8645-6ac74c4a456&title=&width=315.2" alt="image.png"><br />代码块,类中方法外,可以将每个构造方法中相同的内容添加在代码块中,构造方法初始化,优先于对象</p><p>static代码块,在类加载时间执行,只执行一次;主要用于初始化静态变量</p><p><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650540225009-9b8fa7e5-638d-416c-89b3-82d9ae07ce72.png#clientId=u9786de69-939b-4&from=paste&height=487&id=u9bf8eb0c&name=image.png&originHeight=609&originWidth=663&originalType=binary&ratio=1&rotation=0&showTitle=false&size=132223&status=done&style=none&taskId=ub4a40977-cd02-459c-aa8d-576376667c8&title=&width=530.4" alt="image.png"><br />因为类中只能有属性和方法,不能进行其他操作,可以在static代码块中执行,比如 捕获异常</p><p><a name="SuB6L"></a></p><h1 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h1><p>java.util.Arrays 此类包含用来操作数组的各种方法，比如排序和搜索等。其所有方法均为静态方法，调用起来非常简单。 <br />将构造方法设计为private,就无法构造对象;比如Arrays,大部分对象都是静态方法</p><p><strong>Math</strong></p>]]></content>
    
    
    <categories>
      
      <category>JavaSe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>String类</tag>
      
      <tag>static</tag>
      
      <tag>Array类</tag>
      
      <tag>Math类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>009 继承、super、this、抽象类</title>
    <link href="/2020/02/10/009%20%E7%BB%A7%E6%89%BF%E3%80%81super%E3%80%81this%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <url>/2020/02/10/009%20%E7%BB%A7%E6%89%BF%E3%80%81super%E3%80%81this%E3%80%81%E6%8A%BD%E8%B1%A1%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p>JAVA三大特性,封装,继承,多态</p><p><a name="hMo1R"></a></p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类无需再定义这些属性和行为，只要继承那一个类即可<br />多个类可以称为<strong>子类</strong>，单独那一个类称为<strong>父类</strong>、<strong>超类（superclass）</strong>或者<strong>基类</strong>。</p><p><a name="xNPkN"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><p>就是子类继承父类的<strong>属性</strong>和<strong>行为</strong>，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接 <br />访问父类中的<strong>非私有</strong>的属性和行为。<br><a name="o83j7"></a></p><h2 id=""><a href="#" class="headerlink" title=""></a><br /></h2><p><a name="o3575"></a></p><h2 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h2><ol><li>提高<strong>代码的复用性</strong>。 <br />2. 类与类之间产生了关系，是<strong>多态的前提</strong>。</li></ol><p><a name="Pwezu"></a></p><h1 id="成员方法重名——重写-Override"><a href="#成员方法重名——重写-Override" class="headerlink" title="成员方法重名——重写(Override)"></a>成员方法重名——重写(Override)</h1><p>如果子类父类中出现<strong>重名</strong>的成员方法，这时的访问是一种特殊情况，叫做**方法重写 **(Override)。 <br /><strong>方法重写 <strong>：子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效 果，也称为重写或者复写。</strong>声明不变，重新实现</strong>。 </p><p>**注意事项 **<br />1. 子类方法覆盖父类方法，必须要保证权限大于等于父类权限。 <br />2. 子类方法覆盖父类方法，返回值类型、函数名和参数列表都要一模一样。</p><p><a name="NhYye"></a></p><h1 id="super和this"><a href="#super和this" class="headerlink" title="super和this"></a>super和this</h1><p><a name="pgbUK"></a></p><h2 id="父类空间优先于子类对象产生"><a href="#父类空间优先于子类对象产生" class="headerlink" title="父类空间优先于子类对象产生"></a>父类空间优先于子类对象产生</h2><p>在每次创建子类对象时，先初始化父类空间，再创建其子类对象本身。目的在于子类对象中包含了其对应的父类空 间，便可以包含其父类的成员，如果父类成员非private修饰，则子类可以随意使用父类成员。代码体现在子类的构 造方法调用时，一定先调用父类的构造方法。理解图解如下： <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650784519471-5465433d-b23f-4199-bf15-ddf436845135.png#clientId=uc4d4d045-20ee-4&from=paste&height=415&id=u898c2f51&name=image.png&originHeight=519&originWidth=1034&originalType=binary&ratio=1&rotation=0&showTitle=false&size=229145&status=done&style=none&taskId=uecdabba5-6f0e-40a5-b40f-4fd34c9bf6e&title=&width=827.2" alt="image.png"><br><a name="czHhU"></a></p><h2 id="super和this的含义"><a href="#super和this的含义" class="headerlink" title="super和this的含义"></a>super和this的含义</h2><p><strong>super <strong>：代表父类的</strong>存储空间标识</strong>(可以理解为父亲的引用)。 <br /><strong>this <strong>：代表</strong>当前对象的引用</strong>(谁调用就代表谁)。 <br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650764182559-bff1556f-6576-4c23-a73f-a6664b241ef4.png#clientId=uc4d4d045-20ee-4&from=paste&height=710&id=ueed1ec05&name=image.png&originHeight=888&originWidth=1525&originalType=binary&ratio=1&rotation=0&showTitle=false&size=521569&status=done&style=none&taskId=u79e69bfc-c839-4494-8752-ad12dd7126f&title=&width=1220" alt="image.png"></p><p>子类的构造方法,默认会调用父类的构造方法<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1650764649569-5b170e0a-1460-44e5-90bc-382f2da92425.png#clientId=uc4d4d045-20ee-4&from=paste&height=687&id=u376c39e4&name=image.png&originHeight=859&originWidth=898&originalType=binary&ratio=1&rotation=0&showTitle=false&size=252273&status=done&style=none&taskId=u36daeb41-3257-4228-bf5c-c586fbac6f1&title=&width=718.4" alt="image.png"></p><p><a name="uNTIb"></a></p><h1 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h1><ol><li>Java只支持单继承，不支持多继承。 <br />2. Java支持多层继承(继承体系)。<br />3. 子类和父类是一种相对的概念。</li></ol><p>**抽象类 **</p><p>父类中的方法，被它的子类们重写，子类各自的实现都不尽相同。那么父类的方法声明和方法主体，只有声明还有意义，而方法主体则没有存在的意义了。我们把没有方法主体的方法称为<strong>抽象方法</strong>。Java语法规定，包含抽象方法的类就是<strong>抽象类</strong>。 </p><p><a name="GyagY"></a></p><h2 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h2><p>**抽象方法 **： 没有方法体的方法。 <br /><strong>抽象类</strong>：包含抽象方法的类。</p><p><a name="muhKO"></a></p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><p>关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多，但若理解了抽象的本质，无需死记硬背。 <br />1. 抽象类<strong>不能创建对象</strong>，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。 <br />理解：假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。 <br />2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。 <br />理解：子类的构造方法中，有默认的super()，需要访问父类构造方法。 <br />3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。 <br />4. 抽象类的子类，必须重写抽象父类中<strong>所有的</strong>抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。<br />理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有 <br />意义。 </p>]]></content>
    
    
    <categories>
      
      <category>JavaSe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>继承</tag>
      
      <tag>super</tag>
      
      <tag>this</tag>
      
      <tag>抽象类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>011 final、权限、内部类</title>
    <link href="/2020/02/10/011%20final%E3%80%81%E6%9D%83%E9%99%90%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <url>/2020/02/10/011%20final%E3%80%81%E6%9D%83%E9%99%90%E3%80%81%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<p><a name="WASJp"></a></p><h1 id="Final"><a href="#Final" class="headerlink" title="Final"></a>Final</h1><p><strong>Final</strong>： 不可改变。可以用于修饰类、方法和变量。 <br />类：被修饰的类，不能被继承。 <br />方法：被修饰的方法，不能被重写。 <br />变量：被修饰的变量，不能被重新赋值。 </p><p>一般将常量名全部用大写表示</p><p><strong>局部变量——基本类型</strong><br />基本类型的局部变量，被final修饰后，只能赋值一次，不能再更改。<br />**局部变量——引用类型 **<br />引用类型的局部变量，被final修饰后，只能指向一个对象，地址不能再更改。</p><p><a name="E3FQm"></a></p><h1 id="权限修饰符"><a href="#权限修饰符" class="headerlink" title="权限修饰符"></a>权限修饰符</h1><p>public  公共的<br />protect 受保护的<br />default 默认的<br />private 私有的<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1651146093107-d3fb92ad-337f-4ce6-81b5-7f2ef1d4c2eb.png#clientId=ubb8d79da-2a69-4&from=paste&height=208&id=uad0ca63b&name=image.png&originHeight=397&originWidth=1482&originalType=binary&ratio=1&rotation=0&showTitle=false&size=54962&status=done&style=shadow&taskId=u55c993d2-6eb3-4a88-9009-2997cc52786&title=&width=776" alt="image.png"></p><p>回调方法(钩子方法)</p><p>子类的每一个方法开始和结束之前都需要调用一个方法,将该方法写成一个接口,<br />父类中写一个调用该口的方法;<br />在子类中调用执行该接口的方法并按需实现(抽象方法)<br />在父类中调用执行该接口(抽象方法)的方法,<br /><img src="https://cdn.nlark.com/yuque/0/2022/png/22464502/1651581279530-f7d6c74d-afe3-4fea-8f8c-e174c45cc4cd.png#clientId=ub11884bc-faa4-4&from=paste&height=644&id=uecc25586&name=image.png&originHeight=805&originWidth=1409&originalType=binary&ratio=1&rotation=0&showTitle=false&size=411904&status=done&style=none&taskId=u1de983b2-c0ec-4a39-87f9-2397893ec29&title=&width=1127.2" alt="image.png"></p>]]></content>
    
    
    <categories>
      
      <category>JavaSe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>final</tag>
      
      <tag>权限</tag>
      
      <tag>内部类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>010 接口、多态</title>
    <link href="/2020/02/10/010%20%E6%8E%A5%E5%8F%A3%E3%80%81%E5%A4%9A%E6%80%81/"/>
    <url>/2020/02/10/010%20%E6%8E%A5%E5%8F%A3%E3%80%81%E5%A4%9A%E6%80%81/</url>
    
    <content type="html"><![CDATA[<p><a name="b5TyR"></a></p><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p><a name="ANUE5"></a></p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>接口是Java语言中一种引用类型，是方法的集合，如果说类的内部封装了成员变量、构造方法和成员方法，那么接口的内部主要就是<strong>封装了方法.</strong><br />jdk 7 及以前 只有抽象方法与常量(可以省略 public abstract)<br />jdk 8 新增了 默认方法和静态方法(可以省略 public)<br />jdk 9 新增了 私有方法<br />接口的定义，它与定义类方式相似，但是使用 interface 关键字。它也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。 </p><p>引用数据类型：数组，类，接口。 </p><p>接口的使用，它不能创建对象，但是可以被实现（ implements ，类似于被继承）。一个实现接口的（可以看做是接口的子类），需要实现接口中所有的抽象方法，创建该类对象，就可以调用方法了，否则它必须是一个抽象类。</p><p>接口中的私有方法一般由接口中的默认方法来调用;静态方法不能调用非静态方法;<br><a name="rkgA6"></a></p><h2 id="接口中的方法"><a href="#接口中的方法" class="headerlink" title="接口中的方法"></a>接口中的方法</h2><ul><li>抽象方法的使用 <ul><li>必须全部实现</li></ul></li><li>默认方法的使用 <ul><li>可以继承，可以重写，二选一，但是只能通过实现类的对象来调用。</li></ul></li><li>静态方法的使用 <ul><li>静态与.class 文件相关，只能使用接口名调用，不可以通过实现类的类名或者实现类的对象调用</li></ul></li><li>私有方法的使用 <ul><li>私有方法：只有默认方法可以调用。 </li><li>私有静态方法：默认方法和静态方法可以调用。</li></ul></li></ul><p>如果一个接口中有多个默认方法，并且方法中有重复的内容，那么可以抽取出来，封装到私有方法   中，供默认方法去调用。从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。</p><p><a name="GvDUz"></a></p><h2 id="接口的多实现"><a href="#接口的多实现" class="headerlink" title="接口的多实现"></a>接口的多实现</h2><p>一个类只能继承一个父类。而对于接口而言，一个类是可以实现多个接口的，这叫做接口的<strong>多实现</strong>。并且，一个类能继承一个父类，同时实现多个接口。<br><a name="QcwFl"></a></p><h3 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h3><p>接口中，有多个抽象方法时，实现类必须重写所有抽象方法<strong>。如果抽象方法有重名的，只需要重写一次。</strong><br><a name="hsoHH"></a></p><h3 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h3><p>接口中，有多个默认方法时，实现类都可继承使用。<strong>如果默认方法有重名的，必须重写一次。</strong></p><p><a name="pzylR"></a></p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>接口中，存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。 </p><p><a name="huRtW"></a></p><h3 id="优先级的问题"><a href="#优先级的问题" class="headerlink" title="优先级的问题"></a>优先级的问题</h3><p>当一个类，既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近选择执行父类的成员方法。</p><p><a name="ndYwY"></a></p><h2 id="接口的多继承"><a href="#接口的多继承" class="headerlink" title="接口的多继承"></a>接口的多继承</h2><p>一个接口能继承另一个或者多个接口，这和类之间的继承比较相似。接口的继承使用 extends 关键字，子接口继承父接口的方法。<strong>如果父接口中的默认方法有重名的，那么子接口需要重写一次。</strong><br />小贴士： <br />子接口重写默认方法时，default关键字可以保留。 <br />子类重写默认方法时，default关键字不可以保留。</p><p><a name="Me9Vs"></a></p><h2 id="其他成员特点"><a href="#其他成员特点" class="headerlink" title="其他成员特点"></a>其他成员特点</h2><ul><li>接口中，无法定义成员变量，但是可以定义常量，其值不可以改变，默认使用public static fifinal修饰。 </li><li>接口中，没有构造方法，不能创建对象。 </li><li>接口中，没有静态代码块。</li></ul><p><a name="RyM41"></a></p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p><a name="JgRpu"></a></p><h2 id="定义"><a href="#定义" class="headerlink" title="定义:"></a>定义:</h2><p><strong>多态</strong>： 是指同一行为，具有多个不同表现形式。 </p><p><a name="Gk4WM"></a></p><h2 id="前提【重点】"><a href="#前提【重点】" class="headerlink" title="前提【重点】"></a>前提【重点】</h2><ol><li>继承或者实现【二选一】 <br />2. 方法的重写【意义体现：不重写，无意义】 <br />3. 父类引用指向子类对象【格式体现】</li></ol><p><a name="nQ6Ve"></a></p><h2 id="多态的体现"><a href="#多态的体现" class="headerlink" title="多态的体现"></a>多态的体现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">父类类型 变量名 = <span class="hljs-keyword">new</span> 子类对象； <br>变量名.方法名(); <br></code></pre></td></tr></table></figure><p><strong>当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误；如果有，执行的是子类重写后方法。</strong></p><p><a name="Zqpl7"></a></p><h2 id="多态的好处"><a href="#多态的好处" class="headerlink" title="多态的好处"></a>多态的好处</h2><p>实际开发的过程中，父类类型作为方法形式参数，传递子类对象给方法，进行方法的调用，更能体现出多态的扩展性与便利。</p><p><a name="gD3a5"></a></p><h2 id="引用类型转换"><a href="#引用类型转换" class="headerlink" title="引用类型转换"></a>引用类型转换</h2><p>多态的转型分为向上转型与向下转型两种： </p><p><strong>向上转型</strong>：多态本身是子类类型向父类类型向上转换的过程，这个过程是默认的。 <br />当父类引用指向一个子类对象时，便是向上转型。 <br /> <br /><strong>向下转型</strong>：父类类型向子类类型向下转换的过程，这个过程是强制的。 </p><p> <br /><strong>为什么要转型 <strong><br />当使用多态方式调用方法时，首先检查父类中是否有该方法，如果没有，则编译错误。也就是说，</strong>不能调用</strong>子类拥有，而父类没有的方法。编译都错误，更别说运行了。这也是多态给我们带来的一点”小麻烦”。所以，想要调用子类特有的方法，必须做向下转型。 <br />Java提供了 instanceof 关键字，给引用变量做类型的校验</p>]]></content>
    
    
    <categories>
      
      <category>JavaSe</category>
      
    </categories>
    
    
    <tags>
      
      <tag>接口</tag>
      
      <tag>多态</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
